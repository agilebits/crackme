---
title: "Costs"
author: "Jeffrey Goldberg"
date: "4/29/2019"
output: html_document
---

## Prelimaries

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

R is a messy language. Let's find a more functional way to use it with [tidyverse](https://www.tidyverse.org). And some other libraries we'll use.

```{r libraries, warning=FALSE, message=FALSE}
library(tidyverse)
library(knitr)
library(kableExtra)
```


We have [previously calculated](https://discussions.agilebits.com/discussion/comment/470503/#Comment_470503) the cost to check \(2^{32}\) guesses is six US dollars. At some point in the future that cost calculation should be put into this document. For now we will take that as a given constant.

```{r USDper32bits}
usdPer32bit <- 6.00
```

We will also use a simple function for getting from bits to cost to crack. If it turns out that the the name is only used in a few places, we can ditch its name and use it anonymously.

```{r bits2cost}
bits2cost <- function(b) {
  usdPer32bit * 2^(b - 32)
}
```

Now we should also create some data of different kinds of passwords generated in different ways.

```{r pwds}
pwd <- tribble(
  ~type,  ~length, ~separator, ~allow.ucase, ~allow.lcase, ~allow.digit, ~bits,   ~sample,
  "word", 3, "-",     NA,    NA,    NA,    42.48,   "prithee-insured-buoyant",
  "word", 4, "-",     NA,    NA,    NA,    56.65,   "align-caught-boycott-delete",
  "word", 5, "-",     NA,    NA,    NA,    70.81,   "passion-ken-omit-verso-tortoise",
  "word", 3, "digit", NA,    NA,    NA,    49.13,   "swatch2forte1dill",
  "word", 4, "digit", NA,    NA,    NA,    66.61,   "convoy2chant3calf9senorita",
  "word", 5, "digit", NA,    NA,    NA,    84.10,   "slain9dynast5try6punch8licensee",
  "char", 10, NA,     FALSE, TRUE,  TRUE,  50.00,   "fovav9v6ot",
  "char", 9,  NA,     FALSE, TRUE,  TRUE,  45.00,   "azdr3oqxc",
  "char", 8,  NA,     FALSE, TRUE,  TRUE,  40.00,   "2wd74wmq",
  "char", 11, NA,     FALSE, TRUE,  TRUE,  55.00,   "aev7x9cgm3q",
  "char", 12, NA,     FALSE, TRUE,  TRUE,  60.00,   "8cjfqtzj7yx3",
  "char", 8,  NA,     TRUE,  TRUE,  TRUE,  46.25,   "8NhJqHPY",
  "char", 7,  NA,     TRUE,  TRUE,  TRUE,  40.47,   "zCm6hTb",
  "char", 9,  NA,     TRUE,  TRUE,  TRUE,  52.03,   "siFc96vGw",
  "char", 10, NA,     TRUE,  TRUE,  TRUE,  57.81,   "rmrgKDAyeY",
)
```
Now let's compute the costs for the passwords kinds that we've created.


Let's get prettier printing of the cost. 
```{r pretty-cost}
prettyCost <- function(cost) {
  prettyNum(signif(cost, digits=2), big.mark = ",", scientific=FALSE)
}
```

## Wordy description of the generation scheme

It would be nice to translate things like `type:"char", units:8, allow.lcase:TRUE, ...` into something like "8 character password with lowercase, digits" for friendlier display. But sometimes the seemingly easies things in R aren't.

And now we need to put the generation method into words. (Danger, spectucularly ugly code ahead!). As I haven't gotten this to work, this is just some dead code for the moment. Dead and ugly.
```{r method-words}
method_words <- function(type="word", length=4, separator="-", ucase=TRUE, lcase=TRUE, digit=TRUE) {
  if (type == "word") {
    part1 = sprintf("%d words", length)
    if (separator == "digit") {
      part2 = "digit separator"
    } else if (separator == "") {
      part2 = "no separator"
    } else {
      part2 = "constant separator"
    }
    return (paste(part1, part2, sep = " "))
        
  } else if (type == "char") {
    part1 = sprintf("%d characters", length)
    d <- c("uppercase", "lowercase", "digits")
    alloweds = paste(d[c(ucase,lcase,digit)], sep = ", ")
    part2 = paste("with ", alloweds)
    return (paste(part1, part2, sep = " "))
  }
  else {
    stop("type must be \"word\" or \"char\"")
  }
  
}
 
```

And Vectorize it. (The fact that I have to do this reflects my failure to really know how to do things the R way.)

```{r vectorize method}
method_words <- Vectorize(method_words)

```

## Computation and prepping for display

This is a long pipeline, but the components of the pipe are

1. Only include cases whose strength (in bits) is between 40 and 70.
2. Calculate costs
3. Get costs more human readable numbers
4. Select which columns we want in the output
5. Sort (ascending) by strength

```{r cost-comp}
costs_small <- pwd %>% 
  filter(between(bits, 40, 70)) %>%
  mutate(cost = bits2cost(bits)) %>%
  mutate(pretty = prettyCost(cost)) %>%
  select(type, length, separator, allow.lcase, allow.ucase, allow.digit, bits, pretty, sample) %>%
  arrange(bits)
```

## Prettification and display

And now see if we can make a decent table
```{r cost-table}
kable(costs_small,
      col.names = c("Type", "units","Separator", "Lowercase", "Uppercase", 
                    "Digits", "Bits", "Cost (USD)", "Sample"),
      align = "lrccccrrl",
      caption ="Cracking cost for different generation schemes") %>%
  kable_styling(bootstrap_options = c("striped"))
```